<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>light_pipe.processing.sample API documentation</title>
<meta name="description" content="This module contains the definition of `LightPipeSample`, a key component of the
Light-Pipe API. `LightPipeSample` instances are the fundamental unit …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>light_pipe.processing.sample</code></h1>
</header>
<section id="section-intro">
<p>This module contains the definition of <code><a title="light_pipe.processing.sample.LightPipeSample" href="#light_pipe.processing.sample.LightPipeSample">LightPipeSample</a></code>, a key component of the
Light-Pipe API. <code><a title="light_pipe.processing.sample.LightPipeSample" href="#light_pipe.processing.sample.LightPipeSample">LightPipeSample</a></code> instances are the fundamental unit of data
which are generated by <code>LightPipeline</code> instances.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Richard Correro (rcorrero@stanford.edu)&#34;

__doc__ = &#34;&#34;&#34;
This module contains the definition of `LightPipeSample`, a key component of the
Light-Pipe API. `LightPipeSample` instances are the fundamental unit of data
which are generated by `LightPipeline` instances.
&#34;&#34;&#34;


from collections import namedtuple
from typing import Generator, Optional, Sequence, Union

import numpy as np
from light_pipe import raster_io, raster_trans, tiling
from osgeo import gdal

gdal.UseExceptions()


class LightPipeTile(namedtuple(&#34;LightPipeTile&#34;, [&#34;X&#34;, &#34;y&#34;, &#34;band_map&#34;])):
    &#34;&#34;&#34;
    Contains sub-samples of raster data. Created by `LightPipeSample().tile()` 
    instance method.
    &#34;&#34;&#34;
    def __new__(
        cls, X: np.ndarray, y: Optional[np.ndarray] = None, 
        band_map: Optional[dict] = None
    ):
        return tuple.__new__(cls, [X, y, band_map])


class SampleManifest(
    namedtuple(&#34;SampleManifest&#34;, 
        [&#34;uid&#34;, &#34;datasets&#34;, &#34;labels&#34;, &#34;metadata&#34;, &#34;num_datasets&#34;]
    )
):
    MANIFEST_SAMPLE_NUM: int = 0 # Used to make sample unique identifiers
    &#34;&#34;&#34;
    Produced by `SampleMaker` instances and passed into `LightPipeSample` 
    instances as parameters. Used to structure data passing.
    &#34;&#34;&#34;
    def __new__(
        cls, uid: Optional[Union[str, int]] = None, 
        datasets: Optional[Union[Sequence[gdal.Dataset], Sequence[gdal.Dataset]]] = None,
        labels: Optional[Union[Sequence[bool], bool]] = None,
        metadata: Optional[Union[Sequence[dict], dict]] = None,
        num_datasets: Optional[int] = None,
    ):
        if uid is None:
            uid = f&#34;sample_{cls.MANIFEST_SAMPLE_NUM:05d}&#34;
            cls.MANIFEST_SAMPLE_NUM += 1
        if isinstance(datasets, gdal.Dataset) or isinstance(datasets, str):
            datasets = [datasets]
        if isinstance(labels, bool):
            labels = [labels]
        elif labels is None:
            labels = [False for _ in range(len(datasets))]
        if isinstance(metadata, dict):
            metadata = [metadata]
        elif metadata is None:
            metadata = [dict() for _ in range(len(datasets))]
        if num_datasets is None:
            num_datasets = len(datasets)
        return tuple.__new__(cls, [uid, datasets, labels, metadata, num_datasets])

    
    def concatenate(self, manifests, uid: Optional[Union[int, str]] = None):
        if isinstance(manifests, gdal.Dataset) or isinstance(manifests, str):
            manifests = SampleManifest(datasets=manifests) # Don&#39;t use this if you can
        if isinstance(manifests, SampleManifest):
            manifests = [manifests]        
        datasets = self.datasets.copy()
        labels = self.labels.copy()
        metadata = self.metadata.copy()
        num_datasets = self.num_datasets
        for manifest in manifests:
            new_datasets = manifest.datasets
            new_labels = manifest.labels
            new_metadata = manifest.metadata
            new_num_datasets = manifest.num_datasets
            datasets += new_datasets
            labels += new_labels
            metadata += new_metadata
            num_datasets += new_num_datasets      
        new_manifest = SampleManifest(
            uid, datasets, labels, metadata, num_datasets
        )
        return new_manifest


class LightPipeSample:
    &#34;&#34;&#34;
    Serves analysis-ready subsamples from arbitrarily-large raster(s) and 
    contains necessary variables and methods to format &#34;predictions&#34; into
    georeferenced files.
    &#34;&#34;&#34;
    def __init__(
        self, data: Union[SampleManifest, gdal.Dataset, Sequence[gdal.Dataset]],
        preds: Optional[Sequence] = list(), pos_only: Optional[bool] = False, 
        non_null_only: Optional[bool] = False, tile_y: Optional[int] = 224, 
        tile_x: Optional[int] = 224, array_dtype = np.uint16, 
        row_major: Optional[bool] = False, tile_coords: Optional[Sequence] = None,
        shuffle_indices: Optional[Sequence] = None, *args, **kwargs
    ):
        # Create `SampleManifest` if not passed
        if not isinstance(data, SampleManifest):
            data = SampleManifest(datasets=data)
        self.data = data
        
        self.preds = preds
        self.pos_only = pos_only
        self.non_null_only = non_null_only
        self.tile_y = tile_y 
        self.tile_x = tile_x
        self.array_dtype = array_dtype 
        self.row_major = row_major
        self.tile_coords = tile_coords
        self.shuffle_indices = shuffle_indices
        self._i = 0


    def add_data(
        self, 
        data: Union[SampleManifest, gdal.Dataset, Sequence[gdal.Dataset]],
    ):
        if not isinstance(data, SampleManifest):
            data = SampleManifest(datasets=data)
        self.data = self.data.concatenate(data)
        return self


    def __iter__(self):
        return self


    def __next__(self):
        return self.next()


    def next(self):
        i = self._i
        n = self.data.num_datasets
        if i &lt; n:
            self._i += 1
            dataset = self.data.datasets[i]
            if isinstance(dataset, str):
                dataset = gdal.Open(dataset)
            is_label = self.data.labels[i]
            metadata = self.data.metadata[i]
            return dataset, is_label, metadata
        raise StopIteration

    
    def shuffle(
        self, *args, **kwargs
    ) -&gt; None:
        yield from self.tile(shuffle_tiles=True, *args, **kwargs)


    def unshuffle(
        self, preds: Optional[Union[Sequence, np.ndarray]] = None,
        shuffle_indices: Optional[np.ndarray] = None
    ):
        if preds is None:
            preds = self.preds
        assert preds is not None, \
            &#34;`self.preds` instance variable must be set if `preds` not passed as parameter.&#34;
        if not isinstance(preds, np.ndarray):
            preds = np.array(preds)  
        if shuffle_indices is None and self.shuffle_indices is not None:
            shuffle_indices = self.shuffle_indices
        if shuffle_indices is not None:
            unshuffle_indices = np.zeros_like(shuffle_indices)
            unshuffle_indices[shuffle_indices] = np.arange(len(shuffle_indices))
            preds = preds[unshuffle_indices]
        return preds


    def tile(
        self, tile_y: Optional[int] = None, tile_x: Optional[int] = None, 
        array_dtype = None, row_major: Optional[bool] = None, 
        tile_coords = None, pos_only: Optional[bool] = None, 
        non_null_only: Optional[bool] = None, 
        shuffle_tiles: Optional[bool] = False, 
        assert_tile_smaller_than_raster: Optional[bool] = False,
        *args, **kwargs
    ) -&gt; Generator:
        datasets = self.data.datasets
        labels = self.data.labels
        if tile_y is None:
            tile_y = self.tile_y
        else:
            self.tile_y = tile_y
        if tile_x is None:
            tile_x = self.tile_x
        else:
            self.tile_x = tile_x
        if array_dtype is None:
            array_dtype = self.array_dtype
        else:
            self.array_dtype = array_dtype
        if row_major is None:
            row_major = self.row_major
        else:
            self.row_major = row_major
        if tile_coords is None:
            tile_coords = self.tile_coords
        else:
            self.tile_coords = tile_coords
        if pos_only is None:
            pos_only = self.pos_only
        else:
            self.pos_only = pos_only
        if non_null_only is None:
            non_null_only = self.non_null_only
        else:
            self.non_null_only = non_null_only

        datasets, tiles, tile_coords, shuffle_indices, band_map = tiling.get_tiles(
            datasets=datasets, labels=labels, tile_y=tile_y, tile_x=tile_x, 
            array_dtype=array_dtype, row_major=row_major, tile_coords=tile_coords, 
            shuffle_tiles=shuffle_tiles, 
            assert_tile_smaller_than_raster=assert_tile_smaller_than_raster, 
            *args, **kwargs
        )
        self.tile_coords = tile_coords
        self.shuffle_indices = shuffle_indices
        self.band_map = band_map
        for tile_array in tiles:
            X = tile_array[band_map[False]]
            y = tile_array[band_map[True]]

            if pos_only and np.allclose(y, 0):
                continue
            if non_null_only and np.allclose(X, 0):
                continue

            tile = LightPipeTile(X=X, y=y, band_map=band_map)
            yield tile


    def load(self) -&gt; None:
        for i in range(self.data.num_datasets):
            dataset = self.data.datasets[i]
            if isinstance(dataset, str):
                dataset = gdal.Open(dataset)
                self.data.datasets[i] = dataset


    def save(
        self, savepath: str, preds: Optional[Sequence] = None, *args, **kwargs
    ) -&gt; None:
        &#34;&#34;&#34;
        Saves predictions as files using the geospatial metadata associated
        with the `gdal.Dataset` instances in `self.datasets`. Delegates
        based on file extension of `savepath`.
        &#34;&#34;&#34;
        if preds is None:
            preds = self.preds
            assert preds is not None, \
                &#34;`self.preds` instance variable must be set if `preds` not passed as parameter.&#34;
        if not isinstance(preds, np.ndarray):
            preds = np.array(preds)            
        if raster_io.file_is_a(savepath, extension=&#34;.tif&#34;):
            self._save_preds_as_geotiff(
                geotiff_path=savepath, preds=preds, *args, **kwargs
            )
        elif raster_io.file_is_a(savepath, extension=&#34;.csv&#34;):
            self._save_preds_as_csv(
                geotiff_path=savepath, preds=preds, *args, **kwargs
            )
        else:
            raise NotImplementedError(&#34;`save` is not implemented for this file type.&#34;)
        

    def _save_preds_as_geotiff(
        self, geotiff_path: str, preds: np.ndarray, 
        tile_y: Optional[int] = None, tile_x: Optional[int] = None, 
        row_major: Optional[bool] = None, 
        use_ancestor_pixel_size: Optional[bool] = True, 
        pixel_x_size: Optional[Union[int, float]] = None,
        pixel_y_size: Optional[Union[int, float]] = None,
        n_bands: Optional[int] = 1, dtype = gdal.GDT_Byte,
        assert_north_up: Optional[bool] = True, *args, **kwargs
    ) -&gt; None:
        if self.shuffle_indices is not None:
            preds = self.unshuffle(preds=preds)

        if tile_y is None:
            tile_y = self.tile_y
        if tile_x is None:
            tile_x = self.tile_x
        if row_major is None:
            row_major = self.row_major

        _, out_dataset = raster_trans.make_north_up_dataset_from_tiles_like(
            datasets=self.data.datasets, filepath=geotiff_path, tiles=preds,
            tile_y=tile_y, tile_x=tile_x, row_major=row_major, 
            use_ancestor_pixel_size=use_ancestor_pixel_size, 
            pixel_x_size=pixel_x_size, pixel_y_size=pixel_y_size, n_bands=n_bands,
            dtype=dtype, assert_north_up=assert_north_up, *args, **kwargs
        )
        return out_dataset


    def _save_preds_as_csv(
        self, geotiff_path: str, preds: np.ndarray, 
        tile_y: Optional[int] = None, tile_x: Optional[int] = None,
        *args, **kwargs
    ) -&gt; None:
        # @TODO: IMPLEMENT THIS
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="light_pipe.processing.sample.LightPipeSample"><code class="flex name class">
<span>class <span class="ident">LightPipeSample</span></span>
<span>(</span><span>data: Union[<a title="light_pipe.processing.sample.SampleManifest" href="#light_pipe.processing.sample.SampleManifest">SampleManifest</a>, osgeo.gdal.Dataset, Sequence[osgeo.gdal.Dataset]], preds: Optional[Sequence] = [], pos_only: Optional[bool] = False, non_null_only: Optional[bool] = False, tile_y: Optional[int] = 224, tile_x: Optional[int] = 224, array_dtype=numpy.uint16, row_major: Optional[bool] = False, tile_coords: Optional[Sequence] = None, shuffle_indices: Optional[Sequence] = None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Serves analysis-ready subsamples from arbitrarily-large raster(s) and
contains necessary variables and methods to format "predictions" into
georeferenced files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LightPipeSample:
    &#34;&#34;&#34;
    Serves analysis-ready subsamples from arbitrarily-large raster(s) and 
    contains necessary variables and methods to format &#34;predictions&#34; into
    georeferenced files.
    &#34;&#34;&#34;
    def __init__(
        self, data: Union[SampleManifest, gdal.Dataset, Sequence[gdal.Dataset]],
        preds: Optional[Sequence] = list(), pos_only: Optional[bool] = False, 
        non_null_only: Optional[bool] = False, tile_y: Optional[int] = 224, 
        tile_x: Optional[int] = 224, array_dtype = np.uint16, 
        row_major: Optional[bool] = False, tile_coords: Optional[Sequence] = None,
        shuffle_indices: Optional[Sequence] = None, *args, **kwargs
    ):
        # Create `SampleManifest` if not passed
        if not isinstance(data, SampleManifest):
            data = SampleManifest(datasets=data)
        self.data = data
        
        self.preds = preds
        self.pos_only = pos_only
        self.non_null_only = non_null_only
        self.tile_y = tile_y 
        self.tile_x = tile_x
        self.array_dtype = array_dtype 
        self.row_major = row_major
        self.tile_coords = tile_coords
        self.shuffle_indices = shuffle_indices
        self._i = 0


    def add_data(
        self, 
        data: Union[SampleManifest, gdal.Dataset, Sequence[gdal.Dataset]],
    ):
        if not isinstance(data, SampleManifest):
            data = SampleManifest(datasets=data)
        self.data = self.data.concatenate(data)
        return self


    def __iter__(self):
        return self


    def __next__(self):
        return self.next()


    def next(self):
        i = self._i
        n = self.data.num_datasets
        if i &lt; n:
            self._i += 1
            dataset = self.data.datasets[i]
            if isinstance(dataset, str):
                dataset = gdal.Open(dataset)
            is_label = self.data.labels[i]
            metadata = self.data.metadata[i]
            return dataset, is_label, metadata
        raise StopIteration

    
    def shuffle(
        self, *args, **kwargs
    ) -&gt; None:
        yield from self.tile(shuffle_tiles=True, *args, **kwargs)


    def unshuffle(
        self, preds: Optional[Union[Sequence, np.ndarray]] = None,
        shuffle_indices: Optional[np.ndarray] = None
    ):
        if preds is None:
            preds = self.preds
        assert preds is not None, \
            &#34;`self.preds` instance variable must be set if `preds` not passed as parameter.&#34;
        if not isinstance(preds, np.ndarray):
            preds = np.array(preds)  
        if shuffle_indices is None and self.shuffle_indices is not None:
            shuffle_indices = self.shuffle_indices
        if shuffle_indices is not None:
            unshuffle_indices = np.zeros_like(shuffle_indices)
            unshuffle_indices[shuffle_indices] = np.arange(len(shuffle_indices))
            preds = preds[unshuffle_indices]
        return preds


    def tile(
        self, tile_y: Optional[int] = None, tile_x: Optional[int] = None, 
        array_dtype = None, row_major: Optional[bool] = None, 
        tile_coords = None, pos_only: Optional[bool] = None, 
        non_null_only: Optional[bool] = None, 
        shuffle_tiles: Optional[bool] = False, 
        assert_tile_smaller_than_raster: Optional[bool] = False,
        *args, **kwargs
    ) -&gt; Generator:
        datasets = self.data.datasets
        labels = self.data.labels
        if tile_y is None:
            tile_y = self.tile_y
        else:
            self.tile_y = tile_y
        if tile_x is None:
            tile_x = self.tile_x
        else:
            self.tile_x = tile_x
        if array_dtype is None:
            array_dtype = self.array_dtype
        else:
            self.array_dtype = array_dtype
        if row_major is None:
            row_major = self.row_major
        else:
            self.row_major = row_major
        if tile_coords is None:
            tile_coords = self.tile_coords
        else:
            self.tile_coords = tile_coords
        if pos_only is None:
            pos_only = self.pos_only
        else:
            self.pos_only = pos_only
        if non_null_only is None:
            non_null_only = self.non_null_only
        else:
            self.non_null_only = non_null_only

        datasets, tiles, tile_coords, shuffle_indices, band_map = tiling.get_tiles(
            datasets=datasets, labels=labels, tile_y=tile_y, tile_x=tile_x, 
            array_dtype=array_dtype, row_major=row_major, tile_coords=tile_coords, 
            shuffle_tiles=shuffle_tiles, 
            assert_tile_smaller_than_raster=assert_tile_smaller_than_raster, 
            *args, **kwargs
        )
        self.tile_coords = tile_coords
        self.shuffle_indices = shuffle_indices
        self.band_map = band_map
        for tile_array in tiles:
            X = tile_array[band_map[False]]
            y = tile_array[band_map[True]]

            if pos_only and np.allclose(y, 0):
                continue
            if non_null_only and np.allclose(X, 0):
                continue

            tile = LightPipeTile(X=X, y=y, band_map=band_map)
            yield tile


    def load(self) -&gt; None:
        for i in range(self.data.num_datasets):
            dataset = self.data.datasets[i]
            if isinstance(dataset, str):
                dataset = gdal.Open(dataset)
                self.data.datasets[i] = dataset


    def save(
        self, savepath: str, preds: Optional[Sequence] = None, *args, **kwargs
    ) -&gt; None:
        &#34;&#34;&#34;
        Saves predictions as files using the geospatial metadata associated
        with the `gdal.Dataset` instances in `self.datasets`. Delegates
        based on file extension of `savepath`.
        &#34;&#34;&#34;
        if preds is None:
            preds = self.preds
            assert preds is not None, \
                &#34;`self.preds` instance variable must be set if `preds` not passed as parameter.&#34;
        if not isinstance(preds, np.ndarray):
            preds = np.array(preds)            
        if raster_io.file_is_a(savepath, extension=&#34;.tif&#34;):
            self._save_preds_as_geotiff(
                geotiff_path=savepath, preds=preds, *args, **kwargs
            )
        elif raster_io.file_is_a(savepath, extension=&#34;.csv&#34;):
            self._save_preds_as_csv(
                geotiff_path=savepath, preds=preds, *args, **kwargs
            )
        else:
            raise NotImplementedError(&#34;`save` is not implemented for this file type.&#34;)
        

    def _save_preds_as_geotiff(
        self, geotiff_path: str, preds: np.ndarray, 
        tile_y: Optional[int] = None, tile_x: Optional[int] = None, 
        row_major: Optional[bool] = None, 
        use_ancestor_pixel_size: Optional[bool] = True, 
        pixel_x_size: Optional[Union[int, float]] = None,
        pixel_y_size: Optional[Union[int, float]] = None,
        n_bands: Optional[int] = 1, dtype = gdal.GDT_Byte,
        assert_north_up: Optional[bool] = True, *args, **kwargs
    ) -&gt; None:
        if self.shuffle_indices is not None:
            preds = self.unshuffle(preds=preds)

        if tile_y is None:
            tile_y = self.tile_y
        if tile_x is None:
            tile_x = self.tile_x
        if row_major is None:
            row_major = self.row_major

        _, out_dataset = raster_trans.make_north_up_dataset_from_tiles_like(
            datasets=self.data.datasets, filepath=geotiff_path, tiles=preds,
            tile_y=tile_y, tile_x=tile_x, row_major=row_major, 
            use_ancestor_pixel_size=use_ancestor_pixel_size, 
            pixel_x_size=pixel_x_size, pixel_y_size=pixel_y_size, n_bands=n_bands,
            dtype=dtype, assert_north_up=assert_north_up, *args, **kwargs
        )
        return out_dataset


    def _save_preds_as_csv(
        self, geotiff_path: str, preds: np.ndarray, 
        tile_y: Optional[int] = None, tile_x: Optional[int] = None,
        *args, **kwargs
    ) -&gt; None:
        # @TODO: IMPLEMENT THIS
        raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="light_pipe.processing.sample.LightPipeSample.add_data"><code class="name flex">
<span>def <span class="ident">add_data</span></span>(<span>self, data: Union[<a title="light_pipe.processing.sample.SampleManifest" href="#light_pipe.processing.sample.SampleManifest">SampleManifest</a>, osgeo.gdal.Dataset, Sequence[osgeo.gdal.Dataset]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_data(
    self, 
    data: Union[SampleManifest, gdal.Dataset, Sequence[gdal.Dataset]],
):
    if not isinstance(data, SampleManifest):
        data = SampleManifest(datasets=data)
    self.data = self.data.concatenate(data)
    return self</code></pre>
</details>
</dd>
<dt id="light_pipe.processing.sample.LightPipeSample.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self) -&gt; None:
    for i in range(self.data.num_datasets):
        dataset = self.data.datasets[i]
        if isinstance(dataset, str):
            dataset = gdal.Open(dataset)
            self.data.datasets[i] = dataset</code></pre>
</details>
</dd>
<dt id="light_pipe.processing.sample.LightPipeSample.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
    i = self._i
    n = self.data.num_datasets
    if i &lt; n:
        self._i += 1
        dataset = self.data.datasets[i]
        if isinstance(dataset, str):
            dataset = gdal.Open(dataset)
        is_label = self.data.labels[i]
        metadata = self.data.metadata[i]
        return dataset, is_label, metadata
    raise StopIteration</code></pre>
</details>
</dd>
<dt id="light_pipe.processing.sample.LightPipeSample.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, savepath: str, preds: Optional[Sequence] = None, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves predictions as files using the geospatial metadata associated
with the <code>gdal.Dataset</code> instances in <code>self.datasets</code>. Delegates
based on file extension of <code>savepath</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(
    self, savepath: str, preds: Optional[Sequence] = None, *args, **kwargs
) -&gt; None:
    &#34;&#34;&#34;
    Saves predictions as files using the geospatial metadata associated
    with the `gdal.Dataset` instances in `self.datasets`. Delegates
    based on file extension of `savepath`.
    &#34;&#34;&#34;
    if preds is None:
        preds = self.preds
        assert preds is not None, \
            &#34;`self.preds` instance variable must be set if `preds` not passed as parameter.&#34;
    if not isinstance(preds, np.ndarray):
        preds = np.array(preds)            
    if raster_io.file_is_a(savepath, extension=&#34;.tif&#34;):
        self._save_preds_as_geotiff(
            geotiff_path=savepath, preds=preds, *args, **kwargs
        )
    elif raster_io.file_is_a(savepath, extension=&#34;.csv&#34;):
        self._save_preds_as_csv(
            geotiff_path=savepath, preds=preds, *args, **kwargs
        )
    else:
        raise NotImplementedError(&#34;`save` is not implemented for this file type.&#34;)</code></pre>
</details>
</dd>
<dt id="light_pipe.processing.sample.LightPipeSample.shuffle"><code class="name flex">
<span>def <span class="ident">shuffle</span></span>(<span>self, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle(
    self, *args, **kwargs
) -&gt; None:
    yield from self.tile(shuffle_tiles=True, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="light_pipe.processing.sample.LightPipeSample.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>self, tile_y: Optional[int] = None, tile_x: Optional[int] = None, array_dtype=None, row_major: Optional[bool] = None, tile_coords=None, pos_only: Optional[bool] = None, non_null_only: Optional[bool] = None, shuffle_tiles: Optional[bool] = False, assert_tile_smaller_than_raster: Optional[bool] = False, *args, **kwargs) ‑> Generator</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(
    self, tile_y: Optional[int] = None, tile_x: Optional[int] = None, 
    array_dtype = None, row_major: Optional[bool] = None, 
    tile_coords = None, pos_only: Optional[bool] = None, 
    non_null_only: Optional[bool] = None, 
    shuffle_tiles: Optional[bool] = False, 
    assert_tile_smaller_than_raster: Optional[bool] = False,
    *args, **kwargs
) -&gt; Generator:
    datasets = self.data.datasets
    labels = self.data.labels
    if tile_y is None:
        tile_y = self.tile_y
    else:
        self.tile_y = tile_y
    if tile_x is None:
        tile_x = self.tile_x
    else:
        self.tile_x = tile_x
    if array_dtype is None:
        array_dtype = self.array_dtype
    else:
        self.array_dtype = array_dtype
    if row_major is None:
        row_major = self.row_major
    else:
        self.row_major = row_major
    if tile_coords is None:
        tile_coords = self.tile_coords
    else:
        self.tile_coords = tile_coords
    if pos_only is None:
        pos_only = self.pos_only
    else:
        self.pos_only = pos_only
    if non_null_only is None:
        non_null_only = self.non_null_only
    else:
        self.non_null_only = non_null_only

    datasets, tiles, tile_coords, shuffle_indices, band_map = tiling.get_tiles(
        datasets=datasets, labels=labels, tile_y=tile_y, tile_x=tile_x, 
        array_dtype=array_dtype, row_major=row_major, tile_coords=tile_coords, 
        shuffle_tiles=shuffle_tiles, 
        assert_tile_smaller_than_raster=assert_tile_smaller_than_raster, 
        *args, **kwargs
    )
    self.tile_coords = tile_coords
    self.shuffle_indices = shuffle_indices
    self.band_map = band_map
    for tile_array in tiles:
        X = tile_array[band_map[False]]
        y = tile_array[band_map[True]]

        if pos_only and np.allclose(y, 0):
            continue
        if non_null_only and np.allclose(X, 0):
            continue

        tile = LightPipeTile(X=X, y=y, band_map=band_map)
        yield tile</code></pre>
</details>
</dd>
<dt id="light_pipe.processing.sample.LightPipeSample.unshuffle"><code class="name flex">
<span>def <span class="ident">unshuffle</span></span>(<span>self, preds: Union[Sequence, numpy.ndarray, ForwardRef(None)] = None, shuffle_indices: Optional[numpy.ndarray] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unshuffle(
    self, preds: Optional[Union[Sequence, np.ndarray]] = None,
    shuffle_indices: Optional[np.ndarray] = None
):
    if preds is None:
        preds = self.preds
    assert preds is not None, \
        &#34;`self.preds` instance variable must be set if `preds` not passed as parameter.&#34;
    if not isinstance(preds, np.ndarray):
        preds = np.array(preds)  
    if shuffle_indices is None and self.shuffle_indices is not None:
        shuffle_indices = self.shuffle_indices
    if shuffle_indices is not None:
        unshuffle_indices = np.zeros_like(shuffle_indices)
        unshuffle_indices[shuffle_indices] = np.arange(len(shuffle_indices))
        preds = preds[unshuffle_indices]
    return preds</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="light_pipe.processing.sample.LightPipeTile"><code class="flex name class">
<span>class <span class="ident">LightPipeTile</span></span>
<span>(</span><span>X: numpy.ndarray, y: Optional[numpy.ndarray] = None, band_map: Optional[dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains sub-samples of raster data. Created by <code><a title="light_pipe.processing.sample.LightPipeSample" href="#light_pipe.processing.sample.LightPipeSample">LightPipeSample</a>.tile()</code>
instance method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LightPipeTile(namedtuple(&#34;LightPipeTile&#34;, [&#34;X&#34;, &#34;y&#34;, &#34;band_map&#34;])):
    &#34;&#34;&#34;
    Contains sub-samples of raster data. Created by `LightPipeSample().tile()` 
    instance method.
    &#34;&#34;&#34;
    def __new__(
        cls, X: np.ndarray, y: Optional[np.ndarray] = None, 
        band_map: Optional[dict] = None
    ):
        return tuple.__new__(cls, [X, y, band_map])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
</dd>
<dt id="light_pipe.processing.sample.SampleManifest"><code class="flex name class">
<span>class <span class="ident">SampleManifest</span></span>
<span>(</span><span>uid: Union[str, int, ForwardRef(None)] = None, datasets: Optional[Sequence[osgeo.gdal.Dataset]] = None, labels: Union[Sequence[bool], bool, ForwardRef(None)] = None, metadata: Union[Sequence[dict], dict, ForwardRef(None)] = None, num_datasets: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>SampleManifest(uid, datasets, labels, metadata, num_datasets)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SampleManifest(
    namedtuple(&#34;SampleManifest&#34;, 
        [&#34;uid&#34;, &#34;datasets&#34;, &#34;labels&#34;, &#34;metadata&#34;, &#34;num_datasets&#34;]
    )
):
    MANIFEST_SAMPLE_NUM: int = 0 # Used to make sample unique identifiers
    &#34;&#34;&#34;
    Produced by `SampleMaker` instances and passed into `LightPipeSample` 
    instances as parameters. Used to structure data passing.
    &#34;&#34;&#34;
    def __new__(
        cls, uid: Optional[Union[str, int]] = None, 
        datasets: Optional[Union[Sequence[gdal.Dataset], Sequence[gdal.Dataset]]] = None,
        labels: Optional[Union[Sequence[bool], bool]] = None,
        metadata: Optional[Union[Sequence[dict], dict]] = None,
        num_datasets: Optional[int] = None,
    ):
        if uid is None:
            uid = f&#34;sample_{cls.MANIFEST_SAMPLE_NUM:05d}&#34;
            cls.MANIFEST_SAMPLE_NUM += 1
        if isinstance(datasets, gdal.Dataset) or isinstance(datasets, str):
            datasets = [datasets]
        if isinstance(labels, bool):
            labels = [labels]
        elif labels is None:
            labels = [False for _ in range(len(datasets))]
        if isinstance(metadata, dict):
            metadata = [metadata]
        elif metadata is None:
            metadata = [dict() for _ in range(len(datasets))]
        if num_datasets is None:
            num_datasets = len(datasets)
        return tuple.__new__(cls, [uid, datasets, labels, metadata, num_datasets])

    
    def concatenate(self, manifests, uid: Optional[Union[int, str]] = None):
        if isinstance(manifests, gdal.Dataset) or isinstance(manifests, str):
            manifests = SampleManifest(datasets=manifests) # Don&#39;t use this if you can
        if isinstance(manifests, SampleManifest):
            manifests = [manifests]        
        datasets = self.datasets.copy()
        labels = self.labels.copy()
        metadata = self.metadata.copy()
        num_datasets = self.num_datasets
        for manifest in manifests:
            new_datasets = manifest.datasets
            new_labels = manifest.labels
            new_metadata = manifest.metadata
            new_num_datasets = manifest.num_datasets
            datasets += new_datasets
            labels += new_labels
            metadata += new_metadata
            num_datasets += new_num_datasets      
        new_manifest = SampleManifest(
            uid, datasets, labels, metadata, num_datasets
        )
        return new_manifest</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="light_pipe.processing.sample.SampleManifest.MANIFEST_SAMPLE_NUM"><code class="name">var <span class="ident">MANIFEST_SAMPLE_NUM</span> : int</code></dt>
<dd>
<div class="desc"><p>Produced by <code>SampleMaker</code> instances and passed into <code><a title="light_pipe.processing.sample.LightPipeSample" href="#light_pipe.processing.sample.LightPipeSample">LightPipeSample</a></code>
instances as parameters. Used to structure data passing.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="light_pipe.processing.sample.SampleManifest.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, manifests, uid: Union[str, int, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, manifests, uid: Optional[Union[int, str]] = None):
    if isinstance(manifests, gdal.Dataset) or isinstance(manifests, str):
        manifests = SampleManifest(datasets=manifests) # Don&#39;t use this if you can
    if isinstance(manifests, SampleManifest):
        manifests = [manifests]        
    datasets = self.datasets.copy()
    labels = self.labels.copy()
    metadata = self.metadata.copy()
    num_datasets = self.num_datasets
    for manifest in manifests:
        new_datasets = manifest.datasets
        new_labels = manifest.labels
        new_metadata = manifest.metadata
        new_num_datasets = manifest.num_datasets
        datasets += new_datasets
        labels += new_labels
        metadata += new_metadata
        num_datasets += new_num_datasets      
    new_manifest = SampleManifest(
        uid, datasets, labels, metadata, num_datasets
    )
    return new_manifest</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="light_pipe.processing" href="index.html">light_pipe.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="light_pipe.processing.sample.LightPipeSample" href="#light_pipe.processing.sample.LightPipeSample">LightPipeSample</a></code></h4>
<ul class="two-column">
<li><code><a title="light_pipe.processing.sample.LightPipeSample.add_data" href="#light_pipe.processing.sample.LightPipeSample.add_data">add_data</a></code></li>
<li><code><a title="light_pipe.processing.sample.LightPipeSample.load" href="#light_pipe.processing.sample.LightPipeSample.load">load</a></code></li>
<li><code><a title="light_pipe.processing.sample.LightPipeSample.next" href="#light_pipe.processing.sample.LightPipeSample.next">next</a></code></li>
<li><code><a title="light_pipe.processing.sample.LightPipeSample.save" href="#light_pipe.processing.sample.LightPipeSample.save">save</a></code></li>
<li><code><a title="light_pipe.processing.sample.LightPipeSample.shuffle" href="#light_pipe.processing.sample.LightPipeSample.shuffle">shuffle</a></code></li>
<li><code><a title="light_pipe.processing.sample.LightPipeSample.tile" href="#light_pipe.processing.sample.LightPipeSample.tile">tile</a></code></li>
<li><code><a title="light_pipe.processing.sample.LightPipeSample.unshuffle" href="#light_pipe.processing.sample.LightPipeSample.unshuffle">unshuffle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="light_pipe.processing.sample.LightPipeTile" href="#light_pipe.processing.sample.LightPipeTile">LightPipeTile</a></code></h4>
</li>
<li>
<h4><code><a title="light_pipe.processing.sample.SampleManifest" href="#light_pipe.processing.sample.SampleManifest">SampleManifest</a></code></h4>
<ul class="">
<li><code><a title="light_pipe.processing.sample.SampleManifest.MANIFEST_SAMPLE_NUM" href="#light_pipe.processing.sample.SampleManifest.MANIFEST_SAMPLE_NUM">MANIFEST_SAMPLE_NUM</a></code></li>
<li><code><a title="light_pipe.processing.sample.SampleManifest.concatenate" href="#light_pipe.processing.sample.SampleManifest.concatenate">concatenate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>